<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Molly - over the bull]]></title><description><![CDATA[notes from the flatiron school in the financial district]]></description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Tue, 21 Oct 2014 13:18:05 GMT</lastBuildDate><atom:link href="http://localhost:2368/author/molly/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[The Perils of Mutable Defaults]]></title><description><![CDATA[<p>Recently I wanted to set up a hash representing some music. In this hash, I needed each key to be an artist name, and each value to be an array representing that artist’s songs.</p>

<p>Pretty straightforward, but I wanted to be able to shovel songs into these song arrays without worrying about whether I’d seen that artist before.</p>

<p>I’d read that you could initialize a hash with a default value, and this seemed like the perfect situation for it — I’d just initialize my hash with a default value of an empty array, like so:</p>

<pre><code class="language-ruby">music_hash = Hash.new([])  
</code></pre>

<p>But when I started populating the hash with my data, I started to notice some weird results. For simplicity I’ll represent this as an IRB session.</p>

<pre><code class="language-ruby">&gt; music_hash["dave matthews band"] &lt;&lt; "tripping billies"
=&gt; ["tripping billies"]
&gt; music_hash["dave matthews band"] &lt;&lt; "crash"
=&gt; ["tripping billies", "crash"]
</code></pre>

<p>So far so good, right? These return values are just as they should be. Let’s take a look at our whole hash.</p>

<pre><code class="language-ruby">&gt; music_hash
=&gt; {}
</code></pre>

<p>Um. It’s empty? Weird... Well, I’ll try adding some more songs.</p>

<pre><code class="language-ruby">&gt; music_hash["calvin harris"] &lt;&lt; "sweet nothing"
=&gt; ["tripping billies", "crash", "sweet nothing"]
&gt; music_hash["avicii"] &lt;&lt; "wake me up"
=&gt; ["tripping billies", "crash", "sweet nothing", "wake me up"]
&gt; music_hash
=&gt; {}
</code></pre>

<p>At this point I was totally baffled. Somehow, even though I had clearly used different keys, all the songs were going into the same array, and all the artists seemed to have all the songs in their arrays. And on top of that, somehow, my hash was still empty!</p>

<p>So what’s going on with this? There’s a clue in the documentation for <a href="http://www.ruby-doc.org/core-1.9.3/Hash.html#method-c-new">Hash::new</a>:</p>

<blockquote>
  <p><strong>new(obj) → new_hash</strong></p>
  
  <p>If <em>obj</em> is specified, this single object will be used for all default values.</p>
</blockquote>

<p><em>This single object</em>. It turns out that when you initialize a hash with a default value of an empty array by writing <code>Hash.new([])</code> or <code>Hash.new(Array.new)</code>, its default value will be <em>that one specific array</em>. This is because that argument is only evaluated once, when the hash is created, and then the resulting array object becomes the default value for every key. When I shoveled my data into it, I wasn’t adding or updating actual key-value pairs in my hash — I was actually mutating that default array.</p>

<p>This explains why all the songs went into the same array, regardless of the key used to add them, and also why my hash stayed empty. I could check the value of a totally new, gibberish key and still get back that same array of songs, because it’s just the default value.</p>

<pre><code class="language-ruby">&gt; music_hash["jak;sdjfkdajf;alsdkfja"]
=&gt; ["tripping billies", "crash", "sweet nothing", "wake me up"]
</code></pre>

<p>So, you’re probably wondering, how <em>do</em> we make the kind of hash we were trying to make — one where each key has its <em>own</em> empty array as a default value?</p>

<p>The solution isn’t the most convenient to type, but it works:</p>

<pre><code class="language-ruby">new_music_hash = Hash.new{ |h,k| h[k] = [] }  
</code></pre>

<p>This works because the block we pass into <code>Hash.new</code> is executed every time a key isn’t found, and therefore each key gets its own personal empty array. As you probably guessed, <code>h</code> stands for ‘hash’ and <code>k</code> stands for ‘key’. </p>

<p>This has some interesting implications because it means that if you wanted to, you could make each key’s default value based on that key in some way. Or you could randomize your default values, or do any number of other weird things. You probably <em>shouldn’t</em>... but you could!</p>

<p>There’s one small potential drawback to this solution. Because the block is evaluated every time a key isn’t found and actually assigns an empty array to the value of that key, just asking the hash for the value of a key will result in that key being inserted into the hash if it wasn’t already there. So if for some reason I wanted to check if I had any songs by a certain artist in my hash...</p>

<pre><code class="language-ruby">&gt; new_music_hash["owen pallett"].empty?
=&gt; true
</code></pre>

<p>...that artist and its empty array would now be part of my hash:</p>

<pre><code class="language-ruby">&gt; new_music_hash
=&gt; {"owen pallett"=&gt;[]}
</code></pre>

<p>If this isn’t what you want, this solution won’t be ideal for you. Luckily, in most cases it will probably be a simple enough workaround to either remove those unwanted key-value pairs from your hash, or just suck it up and use the extra step of conditional assignment rather than initializing with a default value.</p>

<p>Finally, as you might expect, all this hassle is only necessary if the default value you want to use is a mutable type. If you want each key’s default value to be a new string, array, or hash, use the block form. But if you want the default value to be an integer, say 0, you’re fine with <code>Hash.new(0)</code>. Your integer won’t mutate because, well, it’s immutable.</p>

<p>Now go forth and initialize your hashes with maximum efficiency and minimum confusion!</p>]]></description><link>http://localhost:2368/the-perils-of-mutable-defaults/</link><guid isPermaLink="false">bdcc87be-168d-4fe3-99e8-319609af3404</guid><dc:creator><![CDATA[Molly]]></dc:creator><pubDate>Tue, 21 Oct 2014 02:53:25 GMT</pubDate></item><item><title><![CDATA[To Chain or Not to Chain]]></title><description><![CDATA[<p>Chaining methods in Ruby is a great way to get a lot done on just one line. But the more methods you chain together, the greater the chance that your code will have results you might not expect.</p>

<p>So how do you know when to chain your methods? A crucial thing to keep in mind when chaining methods is what each method returns.</p>

<p>Chained methods work because each one operates on the return value of the previous method. So if you can anticipate each method's <strong>return value</strong>, you can anticipate your code's behavior.</p>

<p>Some methods return different kinds of objects depending on the circumstances. For example, say you're storing user input in a variable <code>user_string</code>. Right away, you want to modify the string in place to replace any instances of your three least favorite misspelled words. (Some might question your choice to permanently modify the string — what if you want that data one day? — but you like to walk on the wild side.) So you write the following:</p>

<pre><code>user_string = gets.chomp
user_string.gsub!("definately", "definitely").gsub!("wierd", "weird").gsub!("recieve", "receive")
</code></pre>

<p>Looks good, right? Well, maybe not. It turns out that many bang methods, <code>gsub!</code> included, return <code>nil</code> if they don't actually change anything. So if your user is a great speller — or they just don't use one of the first two words — Ruby will complain of a <code>NoMethodError</code>, because you can't call <code>gsub!</code> on <code>nil</code>.</p>

<p>To make sure your chained methods work regardless of the content of the string, it'd be better to use the non-bang <code>gsub</code>:</p>

<pre><code class="language-ruby">user_string = gets.chomp  
user_string = user_string.gsub("definately", "definitely").gsub("wierd", "weird").gsub("recieve", "receive")  
</code></pre>

<p>or to refrain from chaining:</p>

<pre><code class="language-ruby">user_string = gets.chomp  
user_string.gsub!("definately", "definitely")  
user_string.gsub!("wierd", "weird")  
user_string.gsub!("recieve", "receive")  
</code></pre>

<p>So when to chain? I think a good rule of thumb would be to only chain if you can be sure your methods will have appropriate return values. If they won't, or won't always, you can run into all kinds of unexpected consequences, and it can get confusing fast.</p>

<hr>

<p><strong>Bonus trivia:</strong> Because mathematical operators are technically methods, you can think of many simple arithmetic expressions as chained methods — as long as they share the same operator precedence, anyway: <code>1 + 9 - 3 # =&gt; 7</code> is equivalent to <code>1.+(9).-(3) # =&gt; 7</code>. (Potentially fascinating related question: How is operator precedence [i.e. order of operations] implemented? No, really, tell me!)</p>]]></description><link>http://localhost:2368/to-chain-or-not-to-chain/</link><guid isPermaLink="false">387be1b3-d1a2-4abe-9c7d-c120bcf641ae</guid><category><![CDATA[Flatiron School]]></category><dc:creator><![CDATA[Molly]]></dc:creator><pubDate>Tue, 07 Oct 2014 04:47:37 GMT</pubDate></item></channel></rss>