<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Molly - over the bull]]></title><description><![CDATA[notes from the flatiron school in the financial district]]></description><link>http://localhost:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Tue, 04 Nov 2014 15:01:07 GMT</lastBuildDate><atom:link href="http://localhost:2368/author/molly/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Lessons from a Side Project: Ironboard Batch Tester]]></title><description><![CDATA[<p>Often my ideas for code projects come from using other products and thinking, “I should be able to do this thing” and then realizing, “Hey wait — I think I know enough to make it so I can do this thing!” at which point, of course, I <em>have</em> to do it.</p>

<p>This recent project was no exception. When the new RSpec Ironboard gem was introduced, allowing us to test our local builds and get credit for them on Ironboard, I thought it was pretty awesome. But we had already done so many labs, and I wanted to try it on them, but it seemed like that would mean cding into every lab directory and running the gem manually, which sucks. It occurred to me that I might have the skills to automate this process, so I had to try it.</p>

<p>The result is <a href="https://github.com/molgin/ironboard-batch-tester">Ironboard Batch Tester</a>, a simple script that, given a path to a labs folder and a GitHub username, tests all the available labs and uploads them to Ironboard.</p>

<p>Here’s some of the stuff I learned along the way.</p>

<h4 id="checkingouttherspecironboardcode">Checking out the RSpec Ironboard code</h4>

<p>I could have just automated the process of changing directories and executing the <code>ironboard</code> bash command, but that didn’t seem like the right plan. If the Ironboard gem was written in Ruby and I was writing in Ruby I should just be able to look inside the gem and do whatever it does when that command is run.</p>

<p>Turns out checking out the source code of any Ruby gem is really easy. The command <code>gem unpack rspec-ironboard</code> puts the code in a folder in your working directory where you can rifle through it to your heart’s content. I immediately opened the <code>bin/ironboard</code> file to find out what happens when I run that <code>ironboard</code> command. Here it is:</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby

SERVICE_URL = 'http://ironbroker.flatironschool.com'  
SERVICE_ENDPOINT = '/e/flatiron_rspec/build/ironboard'  
require 'rspec/ironboard'

username = RSpec::Ironboard::UsernameParser.get_username  
user_id = RSpec::Ironboard::UserIdParser.get_user_id  
repo = RSpec::Ironboard::RepoParser.get_repo  
runner = RSpec::Ironboard::Runner.new(username, user_id, repo, ARGV)  
runner.run
</code></pre>

<p>Cool! So basically it gets the user’s github username, user_id, and repo name, and then uses that info (along with <code>ARGV</code> which I know from my brief forays into C contains any command line arguments) to initialize a new <code>Runner</code> object, which it then runs by calling <code>#run</code>.</p>

<p>I checked out how these methods worked as well. To get the username, it just asks the user for their username. It gets the user ID from Github based on the username. It gets the repo name using this code:</p>

<pre><code class="language-ruby">class RepoParser  
      def self.get_repo
        begin
          repo = Git.open(FileUtils.pwd)
        rescue
          puts "Not a valid Git repository"
          die
        end

        url = repo.remote.url

        repo_name = url.match(/(?:https:\/\/|git@).*\/(.+)(?:\.git)/)[1]
      end

      def self.die
        exit
      end
    end
</code></pre>

<p>This creates a <code>Git</code> object based on the current diretory, full of info about the repository, as long as it is one. It gets the remote URL from that and then applies a regex to extract just the repo name from that. This is kinda cool because it could just get the repo name from the directory name, since they’ll be the same by default when cloning, but this works even if the user has changed the name of the directory.</p>

<p>Then it creates and runs the <code>Runner</code> object, which is the meat of the gem. It's kind of long, and <em>mostly</em> its inner workings didn’t affect my project, so I won’t reproduce it here, but I encourage you to <code>gem unpack rspec-ironboard</code> and check it out for yourself.</p>

<h4 id="objectorientedprogrammingreallyisbetter">Object-oriented programming really is better</h4>

<p>When I started, I just wanted to see if I could make the thing work really quick so I just threw together a rather lazy procedural solution. It was pretty much just one long method, as follows:</p>

<pre><code class="language-ruby">def test_all(path, skipped_labs, username, user_id, skip_successful_labs_on_rerun)  
  Dir.chdir path do
    puts Dir.pwd
    f = File.open('.passing_labs', 'a+')
    passing_labs = f.each_line.with_object([]) { |line, ary| ary.push line.strip }
    f.close
    labs = Dir.glob("**/*006/").sort_by{ |f| File.ctime(f) }
    skipped_labs += passing_labs if skip_successful_labs_on_rerun
    skipped_labs.each do |skipped_lab|
      labs.reject! { |lab| lab.include? skipped_lab }
    end
    puts "All the non-skipped labs have already been tested and passed!" if labs.empty?
    labs.each do |lab|
      Dir.chdir lab do
        lab_name = lab.split("/").find { |str| str.include? "-ruby-006" }
        nice_lab_name = lab_name.sub("-ruby-006","").split("-").map(&amp;:capitalize).join(" ")
        puts "\nChecking #{nice_lab_name}...\n\n".magenta
        repo = RSpec::Ironboard::RepoParser.get_repo
        runner = RSpec::Ironboard::Runner.new(username, user_id, repo, [])
        runner.run
        if runner.formatted_results[:failure_count] == 0
          File.open("#{path}/.passing_labs", 'a') do |f|
            f.puts lab_name
          end
        end
      end
    end
  end
end  
</code></pre>

<p>It’s not very pleasant to look at and it wouldn’t be much fun to change. It worked, but I knew I could do better. So I refactored it into an object-oriented version:</p>

<pre><code class="language-ruby">class IronboardTester  
  attr_reader :path, :username
  attr_accessor :skipped_labs, :skip_successful_labs_on_rerun, :passing_labs, :labs

  def initialize(path, username, skipped_labs, skip_successful_labs_on_rerun)
    @path = path
    @username = username
    @skipped_labs = skipped_labs
    @skip_successful_labs_on_rerun = skip_successful_labs_on_rerun
    @passing_labs = read_or_create_log
    @labs = get_labs
  end

  def user_id
    @user_id ||= get_user_id
  end

  def get_user_id
    RSpec::Ironboard::UserIdParser.get_user_id
  end

  def repo
    RSpec::Ironboard::RepoParser.get_repo
  end

  def new_runner(lab)
    RSpec::Ironboard::Runner.new(username, user_id, repo, [])
  end

  def test(lab)
    Dir.chdir "#{lab}" do
      runner = new_runner(lab)
      runner.run
      if runner.formatted_results[:failure_count] == 0
        log(lab)
      end
    end
  end

  def log(lab)
    File.open("#{path}/.passing_labs", 'a') do |f|
      f.puts lab_name(lab)
    end
  end

  def read_or_create_log
    f = File.open("#{path}/.passing_labs", 'a+')
      passing_labs = f.each_line.with_object([]) { |line, ary| ary.push line.strip }
    f.close
    passing_labs
  end

  def get_labs
    Dir.glob("#{path}/**/*006/").sort_by{ |f| File.ctime(f) }
  end

  def skip_passing_labs
    self.skipped_labs = skipped_labs | passing_labs
  end

  def lab_name(lab)
    lab.split("/").find { |str| str.include? "-ruby-006" }.gsub("_", "-")
  end

  def nice_lab_name(lab)
    lab_name(lab).sub("-ruby-006","").split("-").map(&amp;:capitalize).join(" ")
  end

  def announce(lab)
    puts "\nChecking #{nice_lab_name(lab)}...\n".magenta
  end

  def test_all
    labs.each do |lab|
      announce(lab)
      test(lab)
    end
  end

  def run
    self.passing_labs = read_or_create_log
    skip_passing_labs if skip_successful_labs_on_rerun
    puts "All the non-skipped labs have already been tested and passed!".magenta if labs.empty?
    test_all
  end

end
</code></pre>

<p>Obviously it’s longer, but I think it‘s much nicer. I’ve been reading Sandi Metz’s <a href="http://www.poodr.com/"><em>Practical Object-Oriented Design in Ruby</em></a> and I attempted to follow her recommendations of single responsibility for methods and isolation of dependencies. Now if I want to change something (which I have) it’s a lot easier to see what’s what.</p>

<p>I’m sure there are many potentially better ways I could have organized this, but still I was pretty happy with it.</p>

<h4 id="thinkingaboutotherfeatures">Thinking about other features</h4>

<p>Originally I just wanted my program to take in a path to the folder where the user keeps their labs and run the <code>Runner</code> in each folder. But as I worked on it and talked to other people, I realized it needed some adjustments.</p>

<h6 id="abilitytoparsenestedfoldersoflabs">Ability to parse nested folders of labs</h6>

<p>I just keep all my labs in one big folder, but Sam told me he keeps his organized in subfolders by week and day. My original implementation couldn’t handle this, since it just read the name of every top-level folder after cding into the main folder:</p>

<pre><code class="language-ruby">labs = Dir['*']  
</code></pre>

<p>To fix this I figured out that I could use <code>Dir.glob</code> to recursively look through folders, stopping at folders that end in "006" as I expect lab folders to.</p>

<pre><code class="language-ruby ">Dir.glob("#{path}/**/*006/")  
</code></pre>

<p>This could probably be done better, because after all, what if the user has changed the folder names? Maybe I could attempt to check whether each folder is a valid Git repository. But still, this was a significant improvement.</p>

<h6 id="makingitprettier">Making it prettier</h6>

<p>When my tester runs all your local labs at once, it obviously spits out a ton of output. I thought it would be nicer and easier to understand if I could have it announce each lab before testing it, ideally in a color that would stand out.</p>

<p>And of course, there’s a gem for that! <a href="https://github.com/fazibear/colorize">Colorize</a> adds methods that you can call on your strings so that they’ll print in colors:</p>

<pre><code class="language-ruby">require 'colorize'  
...
def announce(lab)  
  puts "\nChecking #{nice_lab_name(lab)}...\n".magenta
end  
</code></pre>

<h6 id="skippinglabsthathavealreadypassed">Skipping labs that have already passed</h6>

<p>When testing I had to run my program a lot, and I also realized that if any labs threw an error, you'd have to run it again. I had already designed a way to add labs to a list and skip them, but what about the labs that have already been tested and passed? There’s unlikely to be a need to re-test them.</p>

<p>So I added a way for my program to keep track of which labs have already passed.</p>

<pre><code class="language-ruby">def test(lab)  
  Dir.chdir "#{lab}" do
    runner = new_runner(lab)
    runner.run
    if runner.formatted_results[:failure_count] == 0
      log(lab)
    end
  end
end

def log(lab)  
  File.open("#{path}/.passing_labs", 'a') do |f|
    f.puts lab_name(lab)
  end
end  
</code></pre>

<p>From looking at the gem source, I found out that the runner object stores the results of each lab’s tests as a hash in an instance variable, <code>formatted_results</code>. The key <code>:failure_count</code> is, well, the failure count. If it’s zero, my program opens a hidden file, <code>.passing_labs</code>, in the main labs directory, and adds that lab’s name to it.</p>

<p>Then each time the program it reads the file and converts its contents into an array with the method <code>read_or_create_log</code>.</p>

<pre><code class="language-ruby">def read_or_create_log  
  f = File.open("#{path}/.passing_labs", 'a+')
    passing_labs = f.each_line.with_object([]) { |line, ary| ary.push line.strip }
  f.close
  passing_labs
end  
</code></pre>

<p>Then it‘s easy for the program to skip the labs in that list, the same way it skips the other skipped labs.</p>

<h4 id="otherfeaturestopossiblyadd">Other features to possibly add</h4>

<p>There are definitely a few ways this program could be improved. A couple that come to mind are...</p>

<ul>
<li><strong>Error handling</strong> - It’s fairly likely that at least one of the hundred-plus labs the program tests will throw an error, in which case currently the program terminates, forcing the user to either fix that lab or manually add its name to the list of skipped labs and re-run the program. It would be nice if, instead, it could print a message explaining the error and ask the user if they’d like to skip the lab and proceed, possibly even storing that information so it will be skipped in the future as well.</li>
<li><strong>Improved user-friendliness</strong> - Currently to use the program, you have to open it up and edit it to assign your labs folder path and your GitHub username to variables. It might be nice if instead it would ask you for this info when you run it, again possibly storing this info for future use and providing an interface for altering other info, like the skipped labs list, as well.</li>
</ul>

<hr>

<p>In the end, I’m really glad I did this project even if I’m the only one to use it. It was really fun and great practice and I learned a ton. I also had some illuminating debugging experiences that I‘ll save for another day.</p>

<p>So far, I’m happy with my compulsion to try to solve every possibly solvable problem I encounter. Even if it’s trivial, it’s worth it for what I learn in the process.</p>]]></description><link>http://localhost:2368/lessons-from-a-side-project-ironboard-batch-tester/</link><guid isPermaLink="false">f4ba2a90-1673-4684-8b6b-465c37681614</guid><category><![CDATA[Flatiron School]]></category><dc:creator><![CDATA[Molly]]></dc:creator><pubDate>Tue, 04 Nov 2014 14:59:46 GMT</pubDate></item><item><title><![CDATA[The Perils of Mutable Defaults]]></title><description><![CDATA[<p>Recently I wanted to set up a hash representing some music. In this hash, I needed each key to be an artist name, and each value to be an array representing that artist’s songs.</p>

<p>Pretty straightforward, but I wanted to be able to shovel songs into these song arrays without worrying about whether I’d seen that artist before.</p>

<p>I’d read that you could initialize a hash with a default value, and this seemed like the perfect situation for it — I’d just initialize my hash with a default value of an empty array, like so:</p>

<pre><code class="language-ruby">music_hash = Hash.new([])  
</code></pre>

<p>But when I started populating the hash with my data, I started to notice some weird results. For simplicity I’ll represent this as an IRB session.</p>

<pre><code class="language-ruby">&gt; music_hash["dave matthews band"] &lt;&lt; "tripping billies"
=&gt; ["tripping billies"]
&gt; music_hash["dave matthews band"] &lt;&lt; "crash"
=&gt; ["tripping billies", "crash"]
</code></pre>

<p>So far so good, right? These return values are just as they should be. Let’s take a look at our whole hash.</p>

<pre><code class="language-ruby">&gt; music_hash
=&gt; {}
</code></pre>

<p>Um. It’s empty? Weird... Well, I’ll try adding some more songs.</p>

<pre><code class="language-ruby">&gt; music_hash["calvin harris"] &lt;&lt; "sweet nothing"
=&gt; ["tripping billies", "crash", "sweet nothing"]
&gt; music_hash["avicii"] &lt;&lt; "wake me up"
=&gt; ["tripping billies", "crash", "sweet nothing", "wake me up"]
&gt; music_hash
=&gt; {}
</code></pre>

<p>At this point I was totally baffled. Somehow, even though I had clearly used different keys, all the songs were going into the same array, and all the artists seemed to have all the songs in their arrays. And on top of that, somehow, my hash was still empty!</p>

<p>So what’s going on with this? There’s a clue in the documentation for <a href="http://www.ruby-doc.org/core-1.9.3/Hash.html#method-c-new">Hash::new</a>:</p>

<blockquote>
  <p><strong>new(obj) → new_hash</strong></p>
  
  <p>If <em>obj</em> is specified, this single object will be used for all default values.</p>
</blockquote>

<p><em>This single object</em>. It turns out that when you initialize a hash with a default value of an empty array by writing <code>Hash.new([])</code> or <code>Hash.new(Array.new)</code>, its default value will be <em>that one specific array</em>. This is because that argument is only evaluated once, when the hash is created, and then the resulting array object becomes the default value for every key. When I shoveled my data into it, I wasn’t adding or updating actual key-value pairs in my hash — I was actually mutating that default array.</p>

<p>This explains why all the songs went into the same array, regardless of the key used to add them, and also why my hash stayed empty. I could check the value of a totally new, gibberish key and still get back that same array of songs, because it’s just the default value.</p>

<pre><code class="language-ruby">&gt; music_hash["jak;sdjfkdajf;alsdkfja"]
=&gt; ["tripping billies", "crash", "sweet nothing", "wake me up"]
</code></pre>

<p>So, you’re probably wondering, how <em>do</em> we make the kind of hash we were trying to make — one where each key has its <em>own</em> empty array as a default value?</p>

<p>The solution isn’t the most convenient to type, but it works:</p>

<pre><code class="language-ruby">new_music_hash = Hash.new{ |h,k| h[k] = [] }  
</code></pre>

<p>This works because the block we pass into <code>Hash.new</code> is executed every time a key isn’t found, and therefore each key gets its own personal empty array. As you probably guessed, <code>h</code> stands for ‘hash’ and <code>k</code> stands for ‘key’. </p>

<p>This has some interesting implications because it means that if you wanted to, you could make each key’s default value based on that key in some way. Or you could randomize your default values, or do any number of other weird things. You probably <em>shouldn’t</em>... but you could!</p>

<p>There’s one small potential drawback to this solution. Because the block is evaluated every time a key isn’t found and actually assigns an empty array to the value of that key, just asking the hash for the value of a key will result in that key being inserted into the hash if it wasn’t already there. So if for some reason I wanted to check if I had any songs by a certain artist in my hash...</p>

<pre><code class="language-ruby">&gt; new_music_hash["owen pallett"].empty?
=&gt; true
</code></pre>

<p>...that artist and its empty array would now be part of my hash:</p>

<pre><code class="language-ruby">&gt; new_music_hash
=&gt; {"owen pallett"=&gt;[]}
</code></pre>

<p>If this isn’t what you want, this solution won’t be ideal for you. Luckily, in most cases it will probably be a simple enough workaround to either remove those unwanted key-value pairs from your hash, or just suck it up and use the extra step of conditional assignment rather than initializing with a default value.</p>

<p>Finally, as you might expect, all this hassle is only necessary if the default value you want to use is a mutable type. If you want each key’s default value to be a new string, array, or hash, use the block form. But if you want the default value to be an integer, say 0, you’re fine with <code>Hash.new(0)</code>. Your integer won’t mutate because, well, it’s immutable.</p>

<p>Now go forth and initialize your hashes with maximum efficiency and minimum confusion!</p>]]></description><link>http://localhost:2368/the-perils-of-mutable-defaults/</link><guid isPermaLink="false">bdcc87be-168d-4fe3-99e8-319609af3404</guid><category><![CDATA[Flatiron School]]></category><dc:creator><![CDATA[Molly]]></dc:creator><pubDate>Tue, 21 Oct 2014 02:53:25 GMT</pubDate></item><item><title><![CDATA[To Chain or Not to Chain]]></title><description><![CDATA[<p>Chaining methods in Ruby is a great way to get a lot done on just one line. But the more methods you chain together, the greater the chance that your code will have results you might not expect.</p>

<p>So how do you know when to chain your methods? A crucial thing to keep in mind when chaining methods is what each method returns.</p>

<p>Chained methods work because each one operates on the return value of the previous method. So if you can anticipate each method's <strong>return value</strong>, you can anticipate your code's behavior.</p>

<p>Some methods return different kinds of objects depending on the circumstances. For example, say you're storing user input in a variable <code>user_string</code>. Right away, you want to modify the string in place to replace any instances of your three least favorite misspelled words. (Some might question your choice to permanently modify the string — what if you want that data one day? — but you like to walk on the wild side.) So you write the following:</p>

<pre><code>user_string = gets.chomp
user_string.gsub!("definately", "definitely").gsub!("wierd", "weird").gsub!("recieve", "receive")
</code></pre>

<p>Looks good, right? Well, maybe not. It turns out that many bang methods, <code>gsub!</code> included, return <code>nil</code> if they don't actually change anything. So if your user is a great speller — or they just don't use one of the first two words — Ruby will complain of a <code>NoMethodError</code>, because you can't call <code>gsub!</code> on <code>nil</code>.</p>

<p>To make sure your chained methods work regardless of the content of the string, it'd be better to use the non-bang <code>gsub</code>:</p>

<pre><code class="language-ruby">user_string = gets.chomp  
user_string = user_string.gsub("definately", "definitely").gsub("wierd", "weird").gsub("recieve", "receive")  
</code></pre>

<p>or to refrain from chaining:</p>

<pre><code class="language-ruby">user_string = gets.chomp  
user_string.gsub!("definately", "definitely")  
user_string.gsub!("wierd", "weird")  
user_string.gsub!("recieve", "receive")  
</code></pre>

<p>So when to chain? I think a good rule of thumb would be to only chain if you can be sure your methods will have appropriate return values. If they won't, or won't always, you can run into all kinds of unexpected consequences, and it can get confusing fast.</p>

<hr>

<p><strong>Bonus trivia:</strong> Because mathematical operators are technically methods, you can think of many simple arithmetic expressions as chained methods — as long as they share the same operator precedence, anyway: <code>1 + 9 - 3 # =&gt; 7</code> is equivalent to <code>1.+(9).-(3) # =&gt; 7</code>. (Potentially fascinating related question: How is operator precedence [i.e. order of operations] implemented? No, really, tell me!)</p>]]></description><link>http://localhost:2368/to-chain-or-not-to-chain/</link><guid isPermaLink="false">387be1b3-d1a2-4abe-9c7d-c120bcf641ae</guid><category><![CDATA[Flatiron School]]></category><dc:creator><![CDATA[Molly]]></dc:creator><pubDate>Tue, 07 Oct 2014 04:47:37 GMT</pubDate></item></channel></rss>